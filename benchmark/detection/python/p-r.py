#!/usr/bin/python

import os
import sys
import argparse
import logging

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from itertools import cycle
import numpy as np


# setup plot details
colors = cycle(['navy', 'turquoise', 'darkorange', 'cornflowerblue', 'teal'])
lw = 2


def parse_result(result):
    recall = []
    precision_easy = []
    precision_moderate = []
    precision_hard = []
    if not os.path.exists(result):
        logging.info('file not exist.')
        return recall, precision
    with open(result, 'r') as fp:
        for line in iter(fp.readline, ''):
            # get recall precsion
            ls = list(line.strip().split())
            if len(ls) != 0:
                recall.append(float(ls[0]))
                precision_easy.append(float(ls[1]))
                precision_moderate.append(float(ls[2]))
                precision_hard.append(float(ls[3]))
    return recall, precision_easy, precision_moderate, precision_hard

def average_precision(precisions):
    sum = 0.
    for i in range(0,len(precisions),4):
        sum += precisions[i]
    average = sum/11.0
    return average

def parse_args():
    parser = argparse.ArgumentParser(description='plot P-R curve from result txt')
    parser.add_argument('--result', dest='result', help='result txt generated by KITTI evaluation')
    args = parser.parse_args()
    logging.info(args)
    return args


def main(args):
    # Load evaluation result from KITTI cpp benchmark (41 recall discretization steps)
    file_name = list(str(args.result).strip().split('/'))[-1]
    recall, precision_easy, precision_moderate, precision_hard = parse_result(args.result)
    if len(recall) == 0: return 0

    # algorithm 1: calculate mAP value
    auc_easy = 0.
    auc_moderate = 0.
    auc_hard = 0.
    prev_rc = 0
    for i in range(len(recall)):
        if recall[i] != prev_rc:
            auc_easy += (recall[i] - prev_rc) * precision_easy[i]
            auc_moderate += (recall[i] - prev_rc) * precision_moderate[i]
            auc_hard += (recall[i] - prev_rc) * precision_hard[i]
            prev_rc = recall[i]

    print "auc:"
    print auc_easy
    print auc_moderate
    print auc_hard
    # algorithm 2: calculate average precision (approximate value of mAP)
    print "averate precision:"
    print average_precision(precision_easy)
    print average_precision(precision_moderate)
    print average_precision(precision_hard)
    
    # Draw result into picture
    plt.figure(1)
    plt.title(file_name)
    plt.xlabel('Recall')
    plt.ylabel('Precsion')
    #plt.plot(recall,precision_easy,'o')
    plt.plot(recall,precision_easy,lw=lw,label='(area={0:0.2f})'.format(auc_easy))
    plt.plot(recall,precision_moderate,lw=lw,label='(area={0:0.2f})'.format(auc_moderate))
    plt.plot(recall,precision_hard,lw=lw,label='(area={0:0.2f})'.format(auc_hard))
    plt.plot(0,1.0)
    plt.plot(1.0,0)
    plt.legend(loc='lower left')
    plt.show()
    plt.savefig(str(file_name).split('.')[0]+'.png')

    return 0


if __name__ == "__main__":
    args = parse_args()
    sys.exit(main(args))

